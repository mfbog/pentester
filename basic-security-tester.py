import requests
from urllib.parse import urljoin, urlparse
import re
import concurrent.futures
import ssl
import socket
from bs4 import BeautifulSoup
import logging
import argparse
import whois
import dns.resolver
from concurrent.futures import ThreadPoolExecutor, as_completed
from requests.exceptions import RequestException
import json
import subprocess
import os

class AdvancedPentestTool:
    def __init__(self, target, output_file=None, verbosity=1):
        self.target = target
        self.base_url = f"http://{target}" if not target.startswith(('http://', 'https://')) else target
        self.session = requests.Session()
        self.session.headers.update({'User-Agent': 'PentestTool/2.0'})
        self.vulnerabilities = []
        self.output_file = output_file
        self.verbosity = verbosity
        logging.basicConfig(level=logging.INFO if verbosity > 0 else logging.ERROR,
                            format='%(asctime)s - %(levelname)s - %(message)s')
        self.logger = logging.getLogger(__name__)

    def run_tests(self):
        self.logger.info(f"Starting advanced pentest for {self.target}")
        
        tests = [
            self.gather_information,
            self.scan_ports,
            self.enumerate_subdomains,
            self.check_https,
            self.check_security_headers,
            self.check_sensitive_files,
            self.check_xss_vulnerability,
            self.check_sql_injection,
            self.check_ssl_vulnerabilities,
            self.check_open_ports,
            self.check_cookie_security,
            self.check_directory_listing,
            self.check_server_version,
            self.check_cors_policy,
            self.check_form_inputs,
            self.check_clickjacking,
            self.check_csrf,
            self.brute_force_directories,
            self.check_outdated_software,
        ]

        with ThreadPoolExecutor(max_workers=10) as executor:
            futures = [executor.submit(test) for test in tests]
            for future in as_completed(futures):
                try:
                    future.result()
                except Exception as e:
                    self.logger.error(f"An error occurred during testing: {str(e)}")

        self.logger.info("Advanced pentest completed")
        self.report_vulnerabilities()

    def gather_information(self):
        self.logger.info("Gathering information about the target...")
        try:
            domain = urlparse(self.base_url).netloc
            ip = socket.gethostbyname(domain)
            self.logger.info(f"Domain: {domain}")
            self.logger.info(f"IP: {ip}")
            
            try:
                import whois
                w = whois.whois(domain)
                self.logger.info(f"Registrar: {w.registrar}")
                self.logger.info(f"Creation Date: {w.creation_date}")
                self.logger.info(f"Expiration Date: {w.expiration_date}")
            except ImportError:
                self.logger.warning("python-whois not installed. Skipping WHOIS information gathering.")
            
            try:
                import dns.resolver
                answers = dns.resolver.resolve(domain, 'MX')
                mx_records = [rdata.exchange.to_text() for rdata in answers]
                self.logger.info(f"MX Records: {', '.join(mx_records)}")
            except ImportError:
                self.logger.warning("dnspython not installed. Skipping DNS information gathering.")
        except Exception as e:
            self.logger.error(f"Error gathering information: {str(e)}")
    def scan_ports(self):
        self.logger.info("Scanning ports...")
        common_ports = [21, 22, 23, 25, 53, 80, 110, 143, 443, 465, 587, 993, 995, 3306, 3389, 5432, 8080, 8443]
        open_ports = []
        hostname = urlparse(self.base_url).netloc
        for port in common_ports:
            try:
                with socket.create_connection((hostname, port), timeout=1):
                    service = socket.getservbyport(port)
                    open_ports.append(f"{port}/{service}")
                    self.logger.info(f"Port {port} is open - {service}")
            except (socket.timeout, ConnectionRefusedError):
                pass
            except Exception as e:
                self.logger.error(f"Error checking port {port}: {str(e)}")
        if open_ports:
            self.add_vulnerability(f"Open ports detected: {', '.join(open_ports)}", "Medium")

    def enumerate_subdomains(self):
        self.logger.info("Enumerating subdomains...")
        domain = urlparse(self.base_url).netloc
        subdomains = ['www', 'mail', 'ftp', 'localhost', 'webmail', 'smtp', 'pop', 'ns1', 'webdisk', 'ns2', 'cpanel', 'whm', 'autodiscover', 'autoconfig', 'm', 'imap', 'test', 'ns', 'blog', 'pop3', 'dev', 'www2', 'admin', 'forum', 'news', 'vpn', 'ns3', 'mail2', 'new', 'mysql', 'old', 'lists', 'support', 'mobile', 'mx', 'static', 'docs', 'beta', 'shop', 'sql', 'secure', 'demo', 'cp', 'calendar', 'wiki', 'web', 'media', 'email', 'images', 'img', 'www1', 'intranet', 'portal', 'video', 'sip', 'dns2', 'api', 'cdn', 'stats', 'dns1', 'ns4', 'www3', 'dns', 'search', 'staging', 'server', 'mx1', 'chat', 'wap', 'my', 'svn', 'mail1', 'sites', 'proxy', 'ads', 'host', 'crm', 'cms', 'backup', 'mx2', 'lyncdiscover', 'info', 'apps', 'download', 'remote', 'db', 'forums', 'store', 'relay', 'files', 'newsletter', 'app', 'live', 'owa', 'en', 'start', 'sms', 'office', 'exchange', 'ipv4']
        
        valid_subdomains = []
        with ThreadPoolExecutor(max_workers=20) as executor:
            futures = [executor.submit(self.check_subdomain, f"{sub}.{domain}") for sub in subdomains]
            for future in as_completed(futures):
                result = future.result()
                if result:
                    valid_subdomains.append(result)
                    self.logger.info(f"Found subdomain: {result}")
        
        if valid_subdomains:
            self.add_vulnerability(f"Subdomains found: {', '.join(valid_subdomains)}", "Info")

    def check_subdomain(self, subdomain):
        try:
            socket.gethostbyname(subdomain)
            return subdomain
        except socket.gaierror:
            return None

    def check_https(self):
        if not self.base_url.startswith("https://"):
            self.add_vulnerability("Site is not using HTTPS", "High")

    def check_security_headers(self):
        try:
            response = self.session.get(self.base_url)
            headers = response.headers
            important_headers = {
                'Strict-Transport-Security': 'HSTS not implemented',
                'X-Frame-Options': 'Clickjacking protection not implemented',
                'X-XSS-Protection': 'XSS protection not implemented',
                'X-Content-Type-Options': 'MIME type sniffing prevention not implemented',
                'Content-Security-Policy': 'Content Security Policy not implemented',
                'Referrer-Policy': 'Referrer Policy not implemented',
                'Permissions-Policy': 'Permissions Policy not implemented'
            }
            for header, message in important_headers.items():
                if header not in headers:
                    self.add_vulnerability(message, "Medium")
        except RequestException as e:
            self.logger.error(f"Error checking security headers: {str(e)}")

    def check_sensitive_files(self):
        sensitive_files = ['/robots.txt', '/sitemap.xml', '/.git/config', '/.env', '/wp-config.php', '/.htaccess', '/backup.sql', '/admin/login.php', '/config.php', '/.svn/entries', '/.DS_Store', '/phpinfo.php']
        for file in sensitive_files:
            url = urljoin(self.base_url, file)
            try:
                response = self.session.get(url)
                if response.status_code == 200:
                    self.add_vulnerability(f"Sensitive file exposed: {url}", "High")
            except RequestException as e:
                self.logger.error(f"Error checking sensitive file {url}: {str(e)}")

    def check_xss_vulnerability(self):
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "javascript:alert('XSS')",
            "<img src=x onerror=alert('XSS')>",
            "<svg/onload=alert('XSS')>",
            "'-alert('XSS')-'",
            "\"><script>alert('XSS')</script>",
            "<scr<script>ipt>alert('XSS')</scr<script>ipt>",
            "<%0AScRiPt%0A>alert('XSS')</ScRiPt>",
        ]
        for payload in xss_payloads:
            try:
                response = self.session.get(f"{self.base_url}?q={payload}")
                if payload in response.text:
                    self.add_vulnerability(f"Potential XSS vulnerability detected with payload: {payload}", "High")
                    break
            except RequestException as e:
                self.logger.error(f"Error checking XSS vulnerability: {str(e)}")

    def check_sql_injection(self):
        sql_payloads = ["' OR '1'='1", "' OR '1'='1' --", "' UNION SELECT NULL, NULL--", "admin' --", "1' ORDER BY 1--", "1' ORDER BY 2--", "1' ORDER BY 3--"]
        for payload in sql_payloads:
            try:
                response = self.session.get(f"{self.base_url}?id={payload}")
                if 'error in your SQL syntax' in response.text:
                    self.add_vulnerability(f"Potential SQL injection vulnerability detected with payload: {payload}", "High")
                    break
            except RequestException as e:
                self.logger.error(f"Error checking SQL injection vulnerability: {str(e)}")

    def check_ssl_vulnerabilities(self):
        hostname = urlparse(self.base_url).netloc
        context = ssl.create_default_context()
        try:
            with socket.create_connection((hostname, 443)) as sock:
                with context.wrap_socket(sock, server_hostname=hostname) as secure_sock:
                    cert = secure_sock.getpeercert()
                    ssl_version = secure_sock.version()
                    cipher = secure_sock.cipher()
                    
                    if ssl_version.startswith(('TLS', 'SSL')):
                        version_num = int(ssl_version.split('v')[1].replace('.', ''))
                        if version_num < 12:
                            self.add_vulnerability(f"Outdated SSL/TLS version: {ssl_version}", "High")
                    
                    weak_ciphers = ['RC4', 'DES', '3DES', 'MD5']
                    if any(weak in cipher[0] for weak in weak_ciphers):
                        self.add_vulnerability(f"Weak cipher suite in use: {cipher[0]}", "High")
                    
                    if 'subjectAltName' not in cert:
                        self.add_vulnerability("SSL certificate missing Subject Alternative Name", "Medium")
                    
                    import datetime
                    cert_expiry = datetime.datetime.strptime(cert['notAfter'], "%b %d %H:%M:%S %Y %Z")
                    if cert_expiry < datetime.datetime.now() + datetime.timedelta(days=30):
                        self.add_vulnerability(f"SSL certificate expiring soon: {cert_expiry}", "Medium")
        except ssl.SSLError as e:
            self.add_vulnerability(f"SSL Error: {str(e)}", "High")
        except Exception as e:
            self.logger.error(f"Error checking SSL vulnerabilities: {str(e)}")

    def check_open_ports(self):
        hostname = urlparse(self.base_url).netloc
        common_ports = [21, 22, 23, 25, 53, 80, 110, 143, 443, 465, 587, 993, 995, 3306, 3389, 5432, 8080, 8443]
        open_ports = []
        for port in common_ports:
            try:
                with socket.create_connection((hostname, port), timeout=1):
                    open_ports.append(port)
            except (socket.timeout, ConnectionRefusedError):
                pass
            except Exception as e:
                self.logger.error(f"Error checking port {port}: {str(e)}")
        if open_ports:
            self.add_vulnerability(f"Open ports detected: {', '.join(map(str, open_ports))}", "Medium")

    def check_cookie_security(self):
        try:
            response = self.session.get(self.base_url)
            for cookie in response.cookies:
                if not cookie.secure:
                    self.add_vulnerability(f"Insecure cookie found: {cookie.name}", "Medium")
                if not cookie.has_nonstandard_attr('HttpOnly'):
                    self.add_vulnerability(f"HttpOnly flag not set for cookie: {cookie.name}", "Low")
                if not cookie.has_nonstandard_attr('SameSite'):
                    self.add_vulnerability(f"SameSite attribute not set for cookie: {cookie.name}", "Low")
        except RequestException as e:
            self.logger.error(f"Error checking cookie security: {str(e)}")

    def check_directory_listing(self):
        test_dirs = ['/images/', '/uploads/', '/backup/', '/admin/', '/css/', '/js/', '/includes/']
        for dir_path in test_dirs:
            try:
                url = urljoin(self.base_url, dir_path)
                response = self.session.get(url)
                if 'Index of' in response.text:
                    self.add_vulnerability(f"Directory listing enabled: {url}", "Medium")
            except RequestException as e:
                self.logger.error(f"Error checking directory listing for {url}: {str(e)}")

    def check_server_version(self):
        try:
            response = self.session.get(self.base_url)
            server = response.headers.get('Server')
            if server:
                self.add_vulnerability(f"Server version disclosed: {server}", "Low")
        except RequestException as e:
            self.logger.error(f"Error checking server version: {str(e)}")
    def check_cors_policy(self):
        headers = {'Origin': 'https://evil.com'}
        try:
            response = self.session.options(self.base_url, headers=headers)
            acao_header = response.headers.get('Access-Control-Allow-Origin')
            if acao_header == '*' or acao_header == 'https://evil.com':
                self.add_vulnerability("Insecure CORS policy detected", "Medium")
        except RequestException as e:
            self.logger.error(f"Error checking CORS policy: {str(e)}")

    def check_form_inputs(self):
        try:
            response = self.session.get(self.base_url)
            soup = BeautifulSoup(response.text, 'html.parser')
            forms = soup.find_all('form')
            for form in forms:
                if form.get('action') and form['action'].startswith('http:'):
                    self.add_vulnerability("Form submitting data over unencrypted HTTP", "High")
                for input_field in form.find_all('input'):
                    if input_field.get('type') == 'password' and not input_field.get('autocomplete') == 'off':
                        self.add_vulnerability("Password field with autocomplete not disabled", "Low")
                    if input_field.get('type') == 'hidden':
                        self.add_vulnerability(f"Hidden input field found: {input_field.get('name')}", "Info")
        except RequestException as e:
            self.logger.error(f"Error checking form inputs: {str(e)}")

    def check_clickjacking(self):
        try:
            response = self.session.get(self.base_url)
            x_frame_options = response.headers.get('X-Frame-Options')
            csp = response.headers.get('Content-Security-Policy')
            if not x_frame_options and not (csp and 'frame-ancestors' in csp):
                self.add_vulnerability("Clickjacking protection not implemented", "Medium")
        except RequestException as e:
            self.logger.error(f"Error checking clickjacking protection: {str(e)}")

    def check_csrf(self):
        try:
            response = self.session.get(self.base_url)
            soup = BeautifulSoup(response.text, 'html.parser')
            forms = soup.find_all('form', method=True)
            for form in forms:
                if form['method'].lower() == 'post':
                    csrf_token = form.find('input', {'name': re.compile(r'csrf|token', re.I)})
                    if not csrf_token:
                        self.add_vulnerability(f"Potential CSRF vulnerability in form: {form.get('action', 'unknown')}", "Medium")
        except RequestException as e:
            self.logger.error(f"Error checking CSRF protection: {str(e)}")

    def brute_force_directories(self):
        wordlist = ['admin', 'backup', 'conf', 'config', 'db', 'debug', 'install', 'log', 'logs', 'login', 'private', 'robot', 'robots', 'secret', 'secrets', 'test', 'tmp', 'upload']
        for word in wordlist:
            url = urljoin(self.base_url, word)
            try:
                response = self.session.get(url)
                if response.status_code == 200:
                    self.add_vulnerability(f"Directory found: {url}", "Medium")
            except RequestException as e:
                self.logger.error(f"Error brute forcing directory {url}: {str(e)}")

    def check_outdated_software(self):
        try:
            response = self.session.get(self.base_url)
            server = response.headers.get('Server', '')
            powered_by = response.headers.get('X-Powered-By', '')

            if 'apache' in server.lower():
                version = re.search(r'Apache/([\d.]+)', server)
                if version and version.group(1) < '2.4.41':
                    self.add_vulnerability(f"Outdated Apache version: {version.group(1)}", "High")
            
            if 'nginx' in server.lower():
                version = re.search(r'nginx/([\d.]+)', server)
                if version and version.group(1) < '1.16.1':
                    self.add_vulnerability(f"Outdated Nginx version: {version.group(1)}", "High")
            
            if 'php' in powered_by.lower():
                version = re.search(r'PHP/([\d.]+)', powered_by)
                if version and version.group(1) < '7.2.0':
                    self.add_vulnerability(f"Outdated PHP version: {version.group(1)}", "High")
        except RequestException as e:
            self.logger.error(f"Error checking outdated software: {str(e)}")

    def add_vulnerability(self, description, severity):
        self.vulnerabilities.append({'description': description, 'severity': severity})

    def report_vulnerabilities(self):
        if not self.vulnerabilities:
            self.logger.info("No vulnerabilities detected.")
        else:
            self.logger.warning("Vulnerabilities detected:")
            for vuln in self.vulnerabilities:
                self.logger.warning(f"[{vuln['severity']}] {vuln['description']}")
        
        if self.output_file:
            with open(self.output_file, 'w') as f:
                json.dump(self.vulnerabilities, f, indent=2)
            self.logger.info(f"Vulnerability report saved to {self.output_file}")

def main():
    parser = argparse.ArgumentParser(description="Advanced Penetration Testing Tool")
    parser.add_argument("target", help="Target URL or IP address")
    parser.add_argument("-o", "--output", help="Output file for the vulnerability report")
    parser.add_argument("-v", "--verbosity", action="count", default=0, help="Increase output verbosity")
    args = parser.parse_args()

    pentest_tool = AdvancedPentestTool(args.target, args.output, args.verbosity)
    pentest_tool.run_tests()

if __name__ == "__main__":
    main()
